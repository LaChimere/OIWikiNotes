# 性质

对于边权为正的图, 任意两个结点之间的最短路, 不会经过重复的结点, 也不会经过重复的边.

对于边权为正的图, 任意两个结点之间的最短路, 任意一条的结点数不会超过 $n$, 边数不会超过 $n - 1$.

# Floyd算法

```c++
void floyd()
{
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (dis[i][k] != INF && dis[k][j] != INF && dis[i][k] + dis[k][j] < dis[i][j])
                    dis[i][j] = dis[i][k] + dis[k][j];
}
```

# Dijkstra算法

不支持带负权值边的图.

邻接矩阵版:

```c++
const int MAXSIZE = 1010;
const int INF = 0x3f3f3f3f;
int n, G[MAXSIZE][MAXSIZE], d[MAXSIZE];
bool visited[MAXSIZE];

void dijkstra(int s)
{
    memset(d, 0x3f, sizeof(d));
    d[s] = 0;
    for (int i = 0; i < n; i++)
    {
        int u = -1, curMin = INF;
        for (int j = 0; j < 0; j++)
        {
            if (!visited[j] && d[j] < curMin)
            {
                u = j;
                curMin = d[j];
            }
        }
        if (u == -1)
            return;
        visited[u] = true;
        for (int v = 0; v < n; v++)
            if (!visited[v] && G[u][v] != INF && d[u] + G[u][v] < d[v])
                d[v] = d[u] + G[u][v];
    }
}
```

邻接表版:

```c++
struct edge {
    int v, w;
};

const int MAXSIZE = 10010;
const int INF = 0x3f3f3f3f;
vector<edge> adj[MAXSIZE];
int n, d[MAXSIZE];
bool visited[MAXSIZE];

void dijkstra(int s)
{
    memset(d, 0x3f, sizeof(d));
    d[s] = 0;
    for (int i = 0; i < n; i++)
    {
        int u = -1, curMin = INF;
        for (int j = 0; j < n; j++)
        {
            if (!visited[j] && d[j] < curMin)
            {
                u = j;
                curMin = d[j];
            }
        }
        if (u == -1)
            return;
        visited[j] = true;
        for (auto e : adj[u])
            if (!visited[e.v] && d[u] + e.w < d[e.v])
                d[e.v] = d[u] + e.w;
    }
}
```